import threading
import socket
import pickle
from concurrent.futures import ThreadPoolExecutor
import numpy as np
import subprocess  # for running netsh to get excluded ports on Windows
import re
import platform  # for system identification to get excluded ports

import sys
import os

# Add the parent directory to sys.path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))


from .constants import *
from .helper_functions import *


from Multidimensional_Data_Structures.kd_tree import KDTree
from Multidimensional_Data_Structures.lsh import LSH
from sklearn.feature_extraction.text import TfidfVectorizer


class PastryNode:

    def __init__(self, network, node_id=None):
        """
        Initialize a new Pastry node with a unique ID, Port, Position, and empty data structures.
        """
        self.network = network  # Reference to the DHT network
        self.running = True
        self.port = self._generate_port()  # IP = (127.0.0.1, Port)

        self.node_id = node_id if node_id is not None else self._generate_id(self.port)
        self.position = None  # Position will be generated by the network
        self.kd_tree = None  # Centralized KD-Tree object

        # 2D Routing Table
        self.routing_table = [[None for j in range(pow(2, b))] for i in range(HASH_HEX_DIGITS)]

        # Leaf Set
        self.Lmin = [None for x in range(L // 2)]
        self.Lmax = [None for x in range(L // 2)]

        # Nearby nodes
        # self.neighborhood_set = [None for x in range(np.floor(np.sqrt(N)).astype(int))]
        self.neighborhood_set = [None for x in range(M)]

        self.lock = threading.Lock()  # Lock for thread safety

        # Create a thread pool for handling requests to limit the number of concurrent threads
        self.thread_pool = ThreadPoolExecutor(max_workers=10)

    # Initialization Methods

    def get_excluded_ports(self):
        """
        Retrieve the list of excluded ports from Windows (netsh) or Linux (/proc/sys/net/ipv4/ip_local_reserved_ports).
        """
        excluded_ports = []

        if platform.system() == "Windows":
            try:
                # Run netsh command to get reserved ports
                output = subprocess.check_output(
                    ["netsh", "int", "ipv4", "show", "excludedportrange", "protocol=tcp"],
                    text=True,
                    shell=True,
                )

                # Extract port ranges using regex
                matches = re.findall(r"(\d+)\s+(\d+)", output)
                for start, end in matches:
                    excluded_ports.append((int(start), int(end)))

            except subprocess.CalledProcessError as e:
                print(f"Failed to retrieve excluded ports on Windows: {e}")

        elif platform.system() == "Linux":
            try:
                # Use 'ss' get occupied ports
                output = subprocess.check_output(["ss", "-tan"], text=True)

                # Extract port numbers from the output
                matches = re.findall(r":(\d+)", output)
                occupied_ports = {int(port) for port in matches}

                # Convert occupied ports to (port, port) format for consistency with Windows
                for port in occupied_ports:
                    excluded_ports.append((port, port))

            except subprocess.CalledProcessError as e:
                print(f"Failed to retrieve occupied ports on Linux using 'ss': {e}")

        return excluded_ports

    def _generate_port(self):
        """
        Generate a unique address Port for the node.
        """
        excluded_ranges = self.get_excluded_ports()

        def is_excluded(port):
            return any(start <= port <= end for start, end in excluded_ranges)

        while True:
            port = np.random.randint(1024, 65535)  # Random port if not provided

            if port not in self.network.used_ports and not is_excluded(port):
                self.network.used_ports.append(port)
                return port

    def _generate_id(self, port):
        """
        Generate a unique node ID by hashing the port.
        """
        port_str = f"{port}"
        node_id = hash_key(port_str)
        return node_id

    # State Inspection

    def get_state(self):
        """
        Returns a formatted string with the state of the node, including:
        - Node ID
        - Port
        - Position
        - Routing Table
        - Leaf Set
        - Neighborhood Set
        - KD Tree Information
        """
        state_info = []
        state_info.append(f"Node ID: {self.node_id}")
        state_info.append(f"Port: {self.port}")
        state_info.append(f"Position: {self.position:.2f}")

        # Routing Table
        state_info.append("\nRouting Table:")

        for row in self.routing_table:
            formatted_row = [
                f"{str(entry) if entry is not None else ' -- '}" for entry in row
            ]  # Fixed-width formatting
            state_info.append("|".join(formatted_row))  # Format as a table row

        # Leaf Set
        state_info.append("\nLeaf Set:")
        state_info.append(f"Lmin: {self.Lmin}")
        state_info.append(f"Lmax: {self.Lmax}")

        # Neighborhood Set
        state_info.append("\nNeighborhood Set:")
        state_info.append(str(self.neighborhood_set))

        # KD Tree Information
        state_info.append("\nKD Tree:\nUnique Country Keys:")
        if not self.kd_tree or self.kd_tree.country_keys.size == 0:
            state_info.append("[]")  # Empty KD Tree
        else:
            unique_keys, counts = np.unique(self.kd_tree.country_keys, return_counts=True)
            state_info.append(f"{list(map(str, unique_keys))}")

            # Country count table
            state_info.append("\nNumber of points/reviews for each country:")
            state_info.append(f"{'Country Key':<12} | {'Country Name':<14} | {'Count':<6}")
            state_info.append("-" * 38)

            country_map = dict(zip(self.kd_tree.country_keys, self.kd_tree.countries))
            for key, count in zip(unique_keys, counts):
                state_info.append(f"{key:<12} | {country_map[key]:<14} | {count:<6}")

        return "\n".join(state_info)

    def print_state(self):
        """
        Print the state of the node (ID, Port, Position, Data Structures).
        """
        print(self.get_state())

    # Network Communication

    def start_server(self):
        """
        Start the server thread to listen for incoming requests.
        """
        server_thread = threading.Thread(target=self._server, daemon=True)
        server_thread.start()

    def _server(self):
        """
        Set up a socket server to handle incoming requests.
        """
        # Use loopback for actual binding
        bind_ip = "127.0.0.1"  # Bind to localhost for real communication
        bind_address = (bind_ip, self.port)

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            try:
                s.bind(bind_address)  # Bind to localhost
            except OSError as e:
                print(f"Error binding to {bind_address}: {e}")
                return

            s.listen()
            s.settimeout(1.0)

            print(f"Node {self.node_id} listening on {bind_address}")

            try:
                while self.running:
                    try:
                        conn, addr = s.accept()  # Accept incoming connection
                        if not self.running:  # If shutting down, close connection
                            conn.close()
                            break
                        self.thread_pool.submit(self._handle_request, conn)
                    except socket.timeout:
                        continue  # Check `self.running` flag again
                    except OSError as e:
                        if self.running:  # Only log errors if still running
                            print(f"Server Error: {e}")
                        break  # Exit loop if socket is already closed
            finally:
                # Shutdown the thread pool when exiting
                self.thread_pool.shutdown(wait=False)
                print(f"Node {self.node_id} server shutting down.")

    def _handle_request(self, conn):
        try:
            data = conn.recv(4096)  # Read up to 1024 bytes of data
            request = pickle.loads(data)  # Deserialize the request
            operation = request["operation"]
            hops = request.get("hops", [])

            # print(f"Node {self.node_id}: Handling Request: {request}")
            response = None

            # Append the current node to the hops list only in main operations
            if operation in main_operations:
                hops.append(self.node_id)
                print(f"Node {self.node_id}: Handling Request: {request}")

            if operation == "NODE_JOIN":
                response = self._handle_join_request(request)
            elif operation == "NODE_LEAVE":
                response = self._handle_leave_request(request)
            elif operation == "INSERT_KEY":
                response = self._handle_insert_key_request(request)
            elif operation == "UPDATE_KEY":
                response = self._handle_update_key_request(request)
            elif operation == "DELETE_KEY":
                response = self._handle_delete_key_request(request)
            elif operation == "LOOKUP":
                response = self._handle_lookup_request(request)
            elif operation == "UPDATE_PRESENCE":
                response = self._handle_update_presence_request(request)
            elif operation == "UPDATE_ROUTING_TABLE_ROW":
                response = self.update_routing_table_row(request)
            elif operation == "UPDATE_ROUTING_TABLE_ENTRY":
                response = self.update_routing_table_entry(request)
            elif operation == "UPDATE_LEAF_SET":
                response = self.update_leaf_set(request)
            elif operation == "REBUILD_NODE_STATE":
                response = self._rebuild_node_state(request)
            elif operation == "DISTANCE":
                distance = topological_distance(self.position, request["node_position"])
                response = {
                    "distance": distance,
                    "neighborhood_set": self.neighborhood_set,
                    "hops": hops,
                }
            elif operation == "GET_LEAF_SET":
                response = {
                    "status": "success",
                    "leaf_set": {"Lmin": self.Lmin, "Lmax": self.Lmax},
                    "hops": hops,
                }
            elif operation == "GET_NEIGHBORHOOD_SET":  # New operation
                response = self._handle_get_neighborhood_set(request)

                print(response)
            elif operation == "REQUEST_NEXT_HOP":
                failed_node_id = request["failed_node_id"]
                next_hop = self._find_next_hop(failed_node_id)  # Perform find_next_hop
                response = {"status": "success" if next_hop else "failure", "next_hop": next_hop}
            elif operation == "GET_POSITION":
                response = {"status": "success", "position": self.position}
            elif operation == "GET_KEYS":
                response = self._handle_get_keys_request(request)
            else:
                response = {"status": "failure", "message": "Unknown operation", "hops": hops}

            conn.sendall(pickle.dumps(response))  # Serialize and send the response
        except Exception as e:
            print(f"Error handling request: {e}")
        finally:
            conn.close()

    def send_request(self, port, request):
        """
        Send a request to a specified node. If the node is missing, trigger repair.
        """
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)  # Timeout to avoid long delays
                s.connect(("localhost", port))
                s.sendall(pickle.dumps(request))
                response = s.recv(4096)
                return pickle.loads(response)
        except (socket.error, EOFError, pickle.PickleError):
            print(f"Network: Detected failure of node at port {port}. Initiating repair...")
            return self.repair_node_failure(request)

    def repair_node_failure(self, failed_node_id):
        """
        Repair the network after detecting a failed node.
        Uses log(N) hops to restore routing tables and leaf sets.
        """
        print(f"Node {self.node_id}: Repairing failure of Node {failed_node_id}.")

        # Find the closest alive node to the failed node
        closest_node_id = self._find_closest_alive_node(failed_node_id)

        if not closest_node_id:
            print(f"Node {self.node_id}: No available nodes to repair {failed_node_id}.")
            return {
                "status": "failure",
                "message": f"No available nodes to repair {failed_node_id}.",
            }

        # Inform the closest node to begin repair
        repair_request = {
            "operation": "NODE_REPAIR",
            "failed_node_id": failed_node_id,
            "hops": [],  # Initialize hops tracking
        }
        response = self.send_request(self.network.node_ports[closest_node_id], repair_request)

        # Ensure a structured response is always returned
        if response is None:
            return {
                "status": "failure",
                "message": f"Repair attempt for {failed_node_id} failed due to no response.",
            }
        return response

    def _handle_get_neighborhood_set(self, request):
        """
        Handle a GET_NEIGHBORHOOD_SET operation by returning the current node's neighborhood set.
        """
        try:
            print(f"Node {self.node_id}: Responding to GET_NEIGHBORHOOD_SET request.")
            return {
                "status": "success",
                "neighborhood_set": self.neighborhood_set,
            }
        except Exception as e:
            print(f"Node {self.node_id}: Error responding to GET_NEIGHBORHOOD_SET request: {e}")
            return {
                "status": "failure",
                "message": f"Error: {e}",
            }

    def _repair_routing_table_entry(self, failed_node_id):
        """
        Repair a missing routing table entry for a failed node.
        Ensures that the replacement has the same prefix length as the failed node.
        """
        print(
            f"Node {self.node_id}: Repairing routing table entry for failed node {failed_node_id}."
        )
        repair_hops = []  # Track hops specific to the repair process

        row_idx = common_prefix_length(self.node_id, failed_node_id)
        col_idx = int(failed_node_id[row_idx], 16)

        # Step 1: Remove failed entry
        self.routing_table[row_idx][col_idx] = None

        # Step 2: Try to get a replacement from another node in the same row
        for entry in self.routing_table[row_idx]:
            if entry and entry != failed_node_id:
                try:
                    request = {
                        "operation": "GET_ROUTING_TABLE_ENTRY",
                        "row_idx": row_idx,
                        "col_idx": col_idx,
                    }
                    response = self.send_request(self.network.node_ports[entry], request)
                    if response["status"] == "success" and response.get("entry"):
                        replacement = response["entry"]

                        if (
                            replacement != failed_node_id
                            and common_prefix_length(self.node_id, replacement) == row_idx
                        ):
                            self.routing_table[row_idx][col_idx] = replacement
                            repair_hops.append(entry)  # Add hop to repair_hops
                            print(
                                f"Node {self.node_id}: Repaired routing table entry {failed_node_id} using {replacement}."
                            )
                            print(f"Repair Hops: {repair_hops}")  # Log repair hops
                            return replacement
                except Exception as e:
                    print(
                        f"Node {self.node_id}: Error contacting {entry} for routing table repair: {e}"
                    )

        # Step 3: Attempt progressive repair using _find_next_hop
        visited_nodes = set()
        next_hop_id = self._find_next_hop(failed_node_id)

        while next_hop_id and next_hop_id not in visited_nodes:
            visited_nodes.add(next_hop_id)
            repair_hops.append(next_hop_id)  # Track repair hops
            print(f"Node {self.node_id}: Requesting {next_hop_id} to perform _find_next_hop.")

            try:
                repair_request = {"operation": "REQUEST_NEXT_HOP", "failed_node_id": failed_node_id}
                response = self.send_request(self.network.node_ports[next_hop_id], repair_request)

                if response["status"] == "success" and response.get("next_hop"):
                    replacement = response["next_hop"]

                if replacement != failed_node_id:
                    replacement_prefix_length = common_prefix_length(self.node_id, replacement)

                    if replacement_prefix_length == row_idx:  # Ensure prefix length matches row
                        if row_idx == 0:  # If first digit (row 0), match based on column directly
                            if int(replacement[0], 16) == col_idx:
                                self.routing_table[row_idx][col_idx] = replacement
                                print(
                                    f"Node {self.node_id}: Successfully repaired routing table with {replacement}."
                                )
                                print(f"Repair Hops: {repair_hops}")  # Log repair hops
                                return replacement
                        else:  # For deeper rows, ensure the replacement's next hex digit matches column
                            if int(replacement[row_idx], 16) == col_idx:
                                self.routing_table[row_idx][col_idx] = replacement
                                print(
                                    f"Node {self.node_id}: Successfully repaired routing table with {replacement}."
                                )
                                print(f"Repair Hops: {repair_hops}")  # Log repair hops
                                return replacement

                # Continue searching if no valid replacement is found
                next_hop_id = response.get("next_hop", None)

            except Exception as e:
                print(
                    f"Node {self.node_id}: Failed to request routing repair from {next_hop_id}: {e}"
                )
                next_hop_id = None  # Break out of the loop on failure

        # Step 4: If no replacement is found, leave the entry as None
        print(f"Node {self.node_id}: Could not find a suitable replacement for {failed_node_id}.")
        print(f"Repair Hops: {repair_hops}")  # Log repair hops
        self.routing_table[row_idx][col_idx] = None  # Explicitly set to None
        return None

    def _repair_neighborhood_set(self, failed_node_id):
        """
        Repair the neighborhood set by discovering all reachable nodes.
        Expands through both neighborhood sets and leaf sets.
        Finds the closest nodes to the current node based on position.
        """
        print(
            f"Node {self.node_id}: Repairing neighborhood set after detecting failed node {failed_node_id}."
        )

        # Step 1: Check if the failed node was in the neighborhood set
        was_in_neighborhood_set = failed_node_id in self.neighborhood_set
        max_size = len(self.neighborhood_set)

        # Remove the failed node from the neighborhood set
        if was_in_neighborhood_set:
            self.neighborhood_set = [
                node for node in self.neighborhood_set if node != failed_node_id
            ]

        # If the failed node was not in the neighborhood set, no further action needed
        if not was_in_neighborhood_set:
            print(
                f"Node {self.node_id}: Failed node {failed_node_id} was not in the neighborhood set. No repair needed."
            )
            return

        # Step 2: Discover all nodes using BFS-like expansion
        all_candidates = {}  # Store {node_id: position} pairs
        visited_nodes = set()
        nodes_to_visit = list(self.neighborhood_set)  # Start with the current neighborhood set

        while nodes_to_visit:
            current_node = nodes_to_visit.pop(0)
            if current_node and current_node not in visited_nodes:
                visited_nodes.add(current_node)
                try:
                    # Request neighborhood set, leaf set, and position
                    neighbor_request = {"operation": "GET_NEIGHBORHOOD_SET"}
                    leafset_request = {"operation": "GET_LEAF_SET"}
                    position_request = {"operation": "GET_POSITION"}

                    # Get neighborhood set
                    neighbor_response = self.send_request(
                        self.network.node_ports[current_node], neighbor_request
                    )
                    if neighbor_response["status"] == "success":
                        neighbors = neighbor_response["neighborhood_set"]
                        nodes_to_visit.extend(neighbors)  # Expand search through neighbors

                    # Get leaf set
                    leafset_response = self.send_request(
                        self.network.node_ports[current_node], leafset_request
                    )
                    if leafset_response["status"] == "success":
                        leaf_nodes = (
                            leafset_response["leaf_set"]["Lmin"]
                            + leafset_response["leaf_set"]["Lmax"]
                        )
                        nodes_to_visit.extend(leaf_nodes)

                    # Get position of the current node
                    position_response = self.send_request(
                        self.network.node_ports[current_node], position_request
                    )
                    if position_response["status"] == "success":
                        all_candidates[current_node] = position_response["position"]

                except Exception as e:
                    print(
                        f"Node {self.node_id}: Error querying {current_node} for neighborhood or leaf set: {e}"
                    )

        # Step 3: Remove self and failed node from candidates
        if self.node_id in all_candidates:
            del all_candidates[self.node_id]
        if failed_node_id in all_candidates:
            del all_candidates[failed_node_id]

        # Step 4: Sort candidates by distance to the current node's position
        try:
            all_candidates = sorted(all_candidates.items(), key=lambda n: abs(n[1] - self.position))
            sorted_candidates = [node for node, _ in all_candidates]
        except Exception as e:
            print(f"Node {self.node_id}: Error sorting candidates: {e}")
            return

        print(f"Node {self.node_id}: Sorted potential neighbors: {sorted_candidates}")

        # Step 5: Update neighborhood set with the closest nodes
        self.neighborhood_set = sorted_candidates[:max_size]

        # Pad with None if not enough candidates are available
        self.neighborhood_set += [None] * (max_size - len(self.neighborhood_set))

        print(f"Node {self.node_id}: Updated Neighborhood Set: {self.neighborhood_set}")

    def _find_closest_alive_node(self, failed_node_id):
        """
        Find the closest alive node to the given failed_node_id.
        """
        if not isinstance(failed_node_id, str):
            print(
                f"Node {self.node_id}: Invalid failed_node_id: {failed_node_id}. Expected a string."
            )
            return None  # Gracefully handle invalid input

        min_distance = float("inf")
        closest_node_id = None

        # Iterate through all known nodes
        for node_id in self.routing_table:  # Replace with actual available nodes logic
            if node_id == failed_node_id:
                continue  # Skip the failed node

            try:
                distance = abs(int(node_id, 16) - int(failed_node_id, 16))
                if distance < min_distance:
                    min_distance = distance
                    closest_node_id = node_id
            except ValueError as e:
                print(f"Node {self.node_id}: Failed to compute distance for node_id {node_id}: {e}")

        if closest_node_id:
            print(
                f"Node {self.node_id}: Closest alive node to {failed_node_id} is {closest_node_id}."
            )
        else:
            print(f"Node {self.node_id}: No alive node found to repair {failed_node_id}.")
        return closest_node_id

    # Node Joining and Routing

    def _handle_join_request(self, request):
        """
        Handle a request from a new node to join the network.
        """
        new_node_id = request["joining_node_id"]
        hops = request.get("hops", [])

        # Determine the routing table row to update
        i = common_prefix_length(self.node_id, new_node_id)

        # Update the new node's Routing Table row
        update_R_request = {
            "operation": "UPDATE_ROUTING_TABLE_ROW",
            "row_idx": i,
            "received_row": self.routing_table[i],
            "hops": hops,  # Include the updated hops list
        }
        print(
            f"Node {self.node_id}: Updating the new node's Routing Table Row {i} with node's {self.node_id} row {i}..."
        )
        self.send_request(self.network.node_ports[new_node_id], update_R_request)

        next_hop_id = self._find_next_hop(new_node_id)

        if next_hop_id == self.node_id:
            # If the next hop is the current node, update the new node's Leaf Set
            print(
                f"Node {self.node_id}: This node is the numerically closest node to the new node.\nUpdating the new node's Leaf Set..."
            )
            update_L_request = {
                "operation": "UPDATE_LEAF_SET",
                "Lmin": self.Lmin,
                "Lmax": self.Lmax,
                "key": self.node_id,
                "hops": hops,  # Include the updated hops list
            }
            self.send_request(self.network.node_ports[new_node_id], update_L_request)

            return {
                "status": "success",
                "hops": hops,  # Include the final hops list in the response
            }

        # Else forward the request to the next hop
        print(f"\nForwarding JOIN_NETWORK request to node {next_hop_id}...")
        response = self.send_request(self.network.node_ports[next_hop_id], request)
        return response

    def _handle_insert_key_request(self, request):
        """
        Handle an INSERT_KEY operation. If a routing table entry is missing, route around it
        and inform the upstream node of a possible replacement.
        """
        key = request["key"]
        hops = request.get("hops", [])

        next_hop_id = self._find_next_hop(key)
        print(f"Node {self.node_id}: Next hop for key {key} is {next_hop_id}")

        # Step 1: Detect if the next hop is missing
        if next_hop_id and next_hop_id not in self.network.node_ports:
            print(f"Node {self.node_id}: Detected failed node {next_hop_id}. Initiating repair...")

            # Repair routing table before proceeding
            self._repair_routing_table_entry(next_hop_id)
            self._repair_leaf_set(next_hop_id)
            self._repair_neighborhood_set(next_hop_id)

            # After repair, find a new next hop
            next_hop_id = self._find_next_hop(key)

        # Step 2: If this node is responsible for storing the key, insert it
        if next_hop_id == self.node_id:

            if not self.kd_tree:

                print(
                    f"The country is: {request['country']} and the key is: {hash_key(request['country'])}"
                )
                self.kd_tree = KDTree(
                    points=np.array([request["point"]]),
                    reviews=np.array([request["review"]]),
                    country_keys=np.array([hash_key(request["country"])]),
                    countries=np.array([request["country"]]),
                )
            else:

                self.kd_tree.add_point(request["point"], request["review"], request["country"])
                print(
                    f"Node {self.node_id}: Inserted {key} into KDTree. Points now: {self.kd_tree.points.shape}"
                )

            print(f"\nInserted Key: {key}")
            print(f"Point: {request['point']}")
            print(f"Review: {request['review']}")
            print(f"Routed and stored at Node ID: {self.node_id}")
            print(f"Country is {request['country']}")
            print(f"Hops: {hops}")

            return {
                "status": "success",
                "message": f"Key {key} stored at {self.node_id}",
                "hops": hops,
            }

        # Step 3: If forwarding, inform upstream node about the missing entry
        if next_hop_id:
            request["hops"] = hops
            response = self.send_request(self.network.node_ports[next_hop_id], request)

            # If the downstream node finds a replacement, update the routing table
            if response and response.get("replacement"):
                self.routing_table[common_prefix_length(self.node_id, next_hop_id)][
                    int(next_hop_id[0], 16)
                ] = response["replacement"]
                print(
                    f"Node {self.node_id}: Updated routing table with replacement from {next_hop_id}."
                )

            return response

    def _handle_delete_key_request(self, request):
        """
        Handle a DELETE_KEY operation.
        """
        key = request["key"]
        hops = request.get("hops", [])  # Retrieve the current hops list

        next_hop_id = self._find_next_hop(key)
        print(f"next hop is: {next_hop_id}")
        # Step 1: Detect if the next hop is missing
        if next_hop_id and next_hop_id not in self.network.node_ports:
            print(f"Node {self.node_id}: Detected failed node {next_hop_id}. Initiating repair...")

            # Repair routing table before proceeding
            self._repair_routing_table_entry(next_hop_id)
            self._repair_leaf_set(next_hop_id)
            self._repair_neighborhood_set(next_hop_id)

            # After repair, find a new next hop
            next_hop_id = self._find_next_hop(key)

        # If the key belongs to this node (based on leaf set), delete it from the KDTree
        if self._in_leaf_set(key) or next_hop_id == self.node_id:
            with self.lock:
                if not self.kd_tree:
                    print(f"\nNode {self.node_id}: No data for key {key}.")
                    hops.append(self.node_id)
                    return {"status": "failure", "message": f"No data for key {key}.", "hops": hops}

                # Delete the key from the KDTree if it exists
                if key in self.kd_tree.country_keys:
                    print(f"\nNode {self.node_id}: Deleted Key {key}.")
                    self.kd_tree.delete_points(key)
                else:
                    print(f"\nNode {self.node_id}: No data for key {key}.\n")
                    return {"status": "failure", "message": f"No data for key {key}.", "hops": hops}

                # Return success with the hops list
                return {
                    "status": "success",
                    "message": f"Deleted Key {key}.",
                    "hops": hops,  # Include the full hops list in the response
                }

        # Otherwise, forward the request to the next node
        print(f"Forwarding DELETE_KEY Request: {hops}")
        response = self.send_request(self.network.node_ports[next_hop_id], request)

        # Ensure the hops list is returned in the response
        return response

    def _handle_lookup_request(self, request):
        """
        Handle a LOOKUP operation.
        """
        try:
            key = request["key"]
            lower_bounds = request["lower_bounds"]
            upper_bounds = request["upper_bounds"]
            N = request["N"]

            hops = request.get("hops", [])  # Retrieve the current hops list

            next_hop_id = self._find_next_hop(key)

            # Step 1: Detect if the next hop is missing
            if next_hop_id and next_hop_id not in self.network.node_ports:
                print(
                    f"Node {self.node_id}: Detected failed node {next_hop_id}. Initiating repair..."
                )

                # Repair routing table before proceeding
                self._repair_routing_table_entry(next_hop_id)
                self._repair_leaf_set(next_hop_id)
                self._repair_neighborhood_set(next_hop_id)

                # After repair, find a new next hop
                next_hop_id = self._find_next_hop(key)

            # If this key is found in the leaf set or the next hop is the current node, the lookup is successful
            if self._in_leaf_set(key) or next_hop_id == self.node_id:
                print(f"\nNode {self.node_id}: Lookup Key {key} Found.")

                if not self.kd_tree or not self.kd_tree.points.size:
                    print(f"Node {self.node_id}: No data for key {key}.")
                    return {"status": "failure", "message": f"No data for key {key}.", "hops": hops}

                # KD-Tree Range Search
                points, reviews = self.kd_tree.search(key, lower_bounds, upper_bounds)
                print(f"Node {self.node_id}: Found {len(points)} matching points.")
                print(
                    f"Node {self.node_id}: Searching in KDTree. Query bounds: {lower_bounds} - {upper_bounds}"
                )
                print(f"Stored points: {self.kd_tree.points}")

                if len(reviews) == 0:
                    print(f"Node {self.node_id}: No reviews found within the specified range.")
                    return {"status": "success", "points": [], "reviews": [], "hops": hops}

                # LSH Similarity Search
                try:
                    vectorizer = TfidfVectorizer()
                    doc_vectors = vectorizer.fit_transform(reviews).toarray()

                    lsh = LSH(num_bands=4, num_rows=5)
                    for vector in doc_vectors:
                        lsh.add_document(vector)

                    similar_pairs = lsh.find_similar_pairs(N)
                    similar_docs = lsh.find_similar_docs(similar_pairs, reviews, N)

                    print(f"The Hops are: {hops}")
                    print("")
                    print(f"\nThe {N} Most Similar Reviews:\n")

                    for i, doc in enumerate(similar_docs, 1):
                        print(f"{i}. {doc}\n")

                    return {
                        "status": "success",
                        "points_len": len(points),
                        "reviews_len": len(reviews),
                        "similar_reviews_len": len(similar_docs),
                        "hops": hops,  # Include the hops list in the response
                    }
                except ValueError as e:
                    print(f"Node {self.node_id}: Error during LSH similarity search: {e}")
                    return {
                        "status": "failure",
                        "message": f"Error during LSH similarity search: {e}",
                        "hops": hops,  # Include the hops list in the response
                    }

            # Forward the request to the next node
            print(f"Forwarding LOOKUP Request: {hops}")
            response = self.send_request(self.network.node_ports[next_hop_id], request)

            # Ensure the hops list is returned in the response
            return response  # The `hops` list will already be included in the forwarded response.

        except Exception as e:
            print(f"Node {self.node_id}: Error handling LOOKUP request: {e}")
            return {"status": "failure", "message": f"Error: {e}", "hops": hops}

    def _handle_update_key_request(self, request):
        """
        Handle an UPDATE_KEY operation with criteria and update fields.
        """
        key = request["key"]
        criteria = request.get("criteria", None)  # Optional criteria to filter
        update_fields = request["data"]  # Update fields for the KDTree
        hops = request.get("hops", [])

        next_hop_id = self._find_next_hop(key)

        # Step 1: Detect if the next hop is missing
        if next_hop_id and next_hop_id not in self.network.node_ports:
            print(f"Node {self.node_id}: Detected failed node {next_hop_id}. Initiating repair...")

            # Repair routing table before proceeding
            self._repair_routing_table_entry(next_hop_id)
            self._repair_leaf_set(next_hop_id)
            self._repair_neighborhood_set(next_hop_id)

            # After repair, find a new next hop
            next_hop_id = self._find_next_hop(key)

        # If this node is responsible for the key
        if self._in_leaf_set(key) or next_hop_id == self.node_id:
            # Check if the key exists in this node's data structure
            if self.kd_tree and key in self.kd_tree.country_keys:
                # Update the data in the KDTree
                self.kd_tree.update_points(
                    country_key=key,
                    criteria=criteria,
                    update_fields=update_fields,
                )
                print(f"Node {self.node_id}: Key {key} updated successfully.")
                return {
                    "status": "success",
                    "message": f"Key {key} updated successfully.",
                    "hops": hops,  # Include the full hops list in the response
                }
            else:
                print(f"Node {self.node_id}: Key {key} not found.")
                return {"status": "failure", "message": f"Key {key} not found.", "hops": hops}

        # Forward the request to the next hop
        print(f"Forwarding UPDATE_KEY Request: {hops}")
        response = self.send_request(self.network.node_ports[next_hop_id], request)

        # Ensure the hops list is returned in the response
        return response

    def _repair_leaf_set(self, failed_node_id):
        """
        Repair the leaf set by querying all nodes in the current leaf set and
        updating Lmin or Lmax only if the failed node was part of the respective set.
        """
        print(
            f"Node {self.node_id}: Repairing leaf set after detecting failed node {failed_node_id}."
        )

        # Step 1: Determine if the failed node was in Lmin or Lmax
        was_in_lmin = failed_node_id in self.Lmin
        was_in_lmax = failed_node_id in self.Lmax

        # Remove the failed node only from the respective set
        if was_in_lmin:
            self.Lmin = [node for node in self.Lmin if node != failed_node_id]
        if was_in_lmax:
            self.Lmax = [node for node in self.Lmax if node != failed_node_id]

        # Step 2: If the node was not in either set, no further action is needed
        if not was_in_lmin and not was_in_lmax:
            print(
                f"Node {self.node_id}: Failed node {failed_node_id} was not in the leaf set. No repair needed."
            )
            return

        # Step 3: Query all nodes in the current leaf set (Lmin or Lmax) for their leaf sets
        all_candidates = []
        leaf_set_to_query = self.Lmin + self.Lmax  # Query both Lmin and Lmax

        for node in leaf_set_to_query:
            if node and node != failed_node_id:  # Exclude failed node
                try:
                    request = {"operation": "GET_LEAF_SET"}
                    response = self.send_request(self.network.node_ports[node], request)
                    if response["status"] == "success":
                        all_candidates.extend(response["leaf_set"]["Lmin"])
                        all_candidates.extend(response["leaf_set"]["Lmax"])
                except Exception as e:
                    print(f"Node {self.node_id}: Error querying {node} for leaf set: {e}")

        # Step 4: Add current leaf set to the candidates and exclude duplicates, self, and failed node
        all_candidates.extend(leaf_set_to_query)  # Include existing leaf set
        all_candidates = list(set(all_candidates))  # Remove duplicates
        all_candidates = [
            node
            for node in all_candidates
            if node and node != self.node_id and node != failed_node_id
        ]  # Exclude self and failed node

        # Sort candidates by numerical distance to the current node ID
        all_candidates.sort(key=lambda n: abs(int(n, 16) - int(self.node_id, 16)))

        # Step 5: Rebuild the relevant set (Lmin or Lmax)
        if was_in_lmin:
            self.Lmin = [node for node in all_candidates if node < self.node_id][: L // 2]
            self.Lmin += [None] * (L // 2 - len(self.Lmin))  # Pad with None if not enough nodes
            print(f"Node {self.node_id}: Rebuilt Lmin: {self.Lmin}")
        if was_in_lmax:
            self.Lmax = [node for node in all_candidates if node > self.node_id][: L // 2]
            self.Lmax += [None] * (L // 2 - len(self.Lmax))  # Pad with None if not enough nodes
            print(f"Node {self.node_id}: Rebuilt Lmax: {self.Lmax}")

        print(f"Node {self.node_id}: Updated Leaf Set - Lmin: {self.Lmin}, Lmax: {self.Lmax}")

    def _handle_leave_request(self, request):
        """
        Handle a NODE_LEAVE operation to process the departure of a node.
        """
        leaving_node_id = request["leaving_node_id"]
        available_nodes = request.get("available_nodes", [])
        node_positions = request.get("node_positions", {})
        hops = request.get("hops", [])  # Retrieve the current hops list

        print(f"Node {self.node_id}: Handling NODE_LEAVE for {leaving_node_id}.")

        # Remove the leaving node from local data structures
        with self.lock:
            self.Lmin = [node for node in self.Lmin if node != leaving_node_id]
            self.Lmax = [node for node in self.Lmax if node != leaving_node_id]
            self.neighborhood_set = [
                node for node in self.neighborhood_set if node != leaving_node_id
            ]

        # Prepare rebuild request
        rebuild_request = {
            "operation": "REBUILD_NODE_STATE",
            "Lmin": self.Lmin,
            "Lmax": self.Lmax,
            "routing_table": self.routing_table,
            "neighborhood_set": self.neighborhood_set,
            "leaving_node_id": leaving_node_id,
            "available_nodes": available_nodes,
            "node_positions": node_positions,
            "hops": hops,  # Include the updated hops list
        }

        # Notify affected nodes
        affected_nodes = set(self.Lmin + self.Lmax + self.neighborhood_set)

        # Ensure the affected nodes are still in the network
        affected_nodes = [node for node in affected_nodes if node in available_nodes]

        for neighbor_id in affected_nodes:
            if neighbor_id and neighbor_id != self.node_id:
                print(f"Node {self.node_id}: Sending REBUILD_NODE_STATE to {neighbor_id}.")
                self.send_request(self.network.node_ports[neighbor_id], rebuild_request)

        print(f"Node {self.node_id}: Finished processing NODE_LEAVE for {leaving_node_id}.")
        return {
            "status": "success",
            "message": f"Processed NODE_LEAVE for {leaving_node_id}.",
            "hops": hops,
        }

    def _rebuild_node_state(self, request):
        """
        Rebuild the Lmin, Lmax, neighborhood_set, and routing_table of this node.
        """
        print(f"Node {self.node_id}: Rebuilding state.")

        # Get available nodes and their positions from the request
        available_nodes = request.get("available_nodes", [])
        node_positions = request.get("node_positions", {})
        leaving_node_id = request.get("leaving_node_id", None)

        if not available_nodes or not node_positions:
            print(f"Node {self.node_id}: Missing available nodes or positions in the request.")
            return {"status": "failure", "message": "Missing available nodes or positions."}

        # Remove the leaving node from the available nodes
        if leaving_node_id in available_nodes:
            available_nodes.remove(leaving_node_id)

        print(
            f"Node {self.node_id}: Available nodes after removing {leaving_node_id}: {available_nodes}"
        )

        # Rebuild Lmin and Lmax
        self.Lmin = self._find_closest_lower_nodes(available_nodes)
        self.Lmax = self._find_closest_higher_nodes(available_nodes)
        print(f"Node {self.node_id}: Lmin: {self.Lmin}, Lmax: {self.Lmax}")

        # Rebuild neighborhood_set
        self.neighborhood_set = self._update_closest_neighbors(available_nodes, node_positions)
        print(f"Node {self.node_id}: Updated neighborhood_set: {self.neighborhood_set}")

        # Remove entries for the leaving node and track cleared positions
        cleared_positions = []
        for row_idx, row in enumerate(self.routing_table):
            for col_idx, entry in enumerate(row):
                if entry == leaving_node_id:
                    self.routing_table[row_idx][col_idx] = None
                    cleared_positions.append((row_idx, col_idx))

        print(
            f"Node {self.node_id}: Cleared routing table entries for {leaving_node_id}. Cleared positions: {cleared_positions}"
        )

        # Attempt to replace cleared positions
        for row_idx, col_idx in cleared_positions:
            for node_id in available_nodes:
                # Check if the node_id matches the prefix required for this position
                if common_prefix_length(self.node_id, node_id) == row_idx:
                    try:
                        # Verify the column matches the expected digit
                        if int(node_id[row_idx], 16) == col_idx:
                            self.routing_table[row_idx][col_idx] = node_id
                            print(
                                f"Node {self.node_id}: Replaced entry at Row {row_idx}, Column {col_idx} with {node_id}."
                            )
                            break  # Stop looking once a replacement is found
                    except (IndexError, ValueError) as e:
                        print(
                            f"Node {self.node_id}: Skipping invalid node_id {node_id} due to error: {e}"
                        )

        print(f"Node {self.node_id}: Updated routing table: {self.routing_table}")
        return {"status": "success", "message": "Rebuilt node state successfully."}

    def _find_closest_lower_nodes(self, available_nodes):
        """
        Find the closest numerically lower nodes to populate Lmin.
        """
        print(f"\nNode {self.node_id}: Finding closest numerically lower nodes.")
        print(f"Available nodes: {available_nodes}")

        # Filter nodes that are numerically lower than the current node
        lower_nodes = [n for n in available_nodes if int(n, 16) < int(self.node_id, 16)]

        # Compute distances for debugging
        distances = {n: int(self.node_id, 16) - int(n, 16) for n in lower_nodes}

        # Sort nodes by distance
        lower_nodes.sort(key=lambda n: distances[n])

        # Ensure Lmin has exactly L // 2 nodes (fill with None if not enough nodes)
        lmin_size = L // 2
        result = lower_nodes[:lmin_size] + [None] * (lmin_size - len(lower_nodes))

        print(f"Node {self.node_id}: Closest numerically lower nodes: {result}")
        return result

    def _find_closest_higher_nodes(self, available_nodes):
        """
        Find the closest numerically higher nodes to populate Lmax.
        """
        print(f"\nNode {self.node_id}: Finding closest numerically higher nodes.")
        print(f"Available nodes: {available_nodes}")

        # Filter nodes that are numerically higher than the current node
        higher_nodes = [n for n in available_nodes if int(n, 16) > int(self.node_id, 16)]

        # Compute distances for debugging
        distances = {n: int(n, 16) - int(self.node_id, 16) for n in higher_nodes}

        # Sort nodes by distance
        higher_nodes.sort(key=lambda n: distances[n])

        # Ensure Lmax has exactly L // 2 nodes (fill with None if not enough nodes)
        lmax_size = L // 2
        result = higher_nodes[:lmax_size] + [None] * (lmax_size - len(higher_nodes))

        print(f"Node {self.node_id}: Closest numerically higher nodes: {result}")
        return result

    def _update_closest_neighbors(self, available_nodes, node_positions):
        print(f"Updating closest neighbors for Node {self.node_id}")
        print(f"Available nodes: {available_nodes}")
        print(f"Node positions: {node_positions}")

        # Exclude self.node_id from the list
        neighbors = [n for n in available_nodes if n != self.node_id]

        # Validate that all nodes have positions
        for node in neighbors:
            if node not in node_positions:
                print(f"Warning: Node {node} does not have a position in node_positions.")
                return [None] * len(self.neighborhood_set)

        # Sort by proximity to the current node
        neighbors.sort(key=lambda n: abs(node_positions[n] - node_positions[self.node_id]))
        result = neighbors[: len(self.neighborhood_set)] + [None] * (
            len(self.neighborhood_set) - len(neighbors)
        )
        print(f"Updated neighborhood_set: {result}")
        return result

    def _handle_get_keys_request(self, request):
        """
        Handle a GET_KEYS operation to retrieve all keys that belong to the node making the request.
        """
        request_node_id = request["node_id"]

        if not self.kd_tree or self.kd_tree.country_keys.size == 0:
            return {"status": "failure", "message": "No keys stored in this node."}

        keys_to_move = []

        # Check if any country_keys should be moved to the requesting node
        for country_key in np.unique(self.kd_tree.country_keys):
            l = common_prefix_length(self.node_id, country_key)
            if self._is_closer_node(request_node_id, country_key, l, self.node_id):
                keys_to_move.append(country_key)

        for country_key in keys_to_move:
            # Get the corresponding points, reviews, and countries indices
            indices = np.where(self.kd_tree.country_keys == country_key)[0]

            if len(indices) == 0:
                continue  # Skip if no matching indices were found

            for idx in indices:
                point = self.kd_tree.points[idx]
                review = self.kd_tree.reviews[idx]
                country = self.kd_tree.countries[idx]

                # Insert the key and data into the requesting node's KDTree
                insert_request = {
                    "operation": "INSERT_KEY",
                    "key": country_key,
                    "country": country,
                    "point": point,
                    "review": review,
                    "hops": [],
                }
                self.send_request(self.network.node_ports[request_node_id], insert_request)
                print(
                    f"Node {self.node_id}: Moved Key {country_key} with Point {point} to {request_node_id}."
                )

            # Remove the key and data from the current node's KDTree
            print(f"Node {self.node_id}: Deleting Key {country_key} from KDTree.")
            self.kd_tree.delete_points(country_key)

        if len(keys_to_move) > 0:
            print(f"Node {self.node_id}: Moved keys {keys_to_move} to {request_node_id}.\n")
        else:
            print(f"\nNode {self.node_id}: Moved no keys to {request_node_id}.")
        return {
            "status": "success",
            "message": f"Moved keys {keys_to_move} to {request_node_id}.",
        }

    def insert_key(self, key, point, review, country):
        """
        Initiate the INSERT_KEY operation for a given key, point, and review.
        """
        request = {
            "operation": "INSERT_KEY",
            "key": key,
            "country": country,
            "point": point,
            "review": review,
            "hops": [],  # Initialize hops tracking
        }
        print(f"Node {self.node_id}: Initiating INSERT_KEY Request: {request}")

        # Handle the request
        response = self._handle_insert_key_request(request)

        # Optional: Log the final response for debugging
        if response and "hops" in response:
            print(f"Node {self.node_id}: INSERT_KEY Operation Complete. Hops: {response['hops']}")
        else:
            print(f"Node {self.node_id}: INSERT_KEY Operation Failed or No Hops Tracked.")

        return response

    def delete_key(self, key):
        """
        Initiate the DELETE_KEY operation for a given key.
        """
        request = {
            "operation": "DELETE_KEY",
            "key": key,
            "hops": [],  # Initialize hops tracking
        }
        print(f"Node {self.node_id}: Initiating DELETE_KEY Request: {request}")

        # Handle the request
        response = self._handle_delete_key_request(request)

        # Optional: Log the final response for debugging
        if response and "hops" in response:
            print(f"Node {self.node_id}: DELETE_KEY Operation Complete. Hops: {response['hops']}")
        else:
            print(f"Node {self.node_id}: DELETE_KEY Operation Failed or No Hops Tracked.")

        return response

    def lookup(self, key, lower_bounds, upper_bounds, N=5):
        """
        Lookup operation for a given key with KDTree range search and LSH similarity check.
        """
        request = {
            "operation": "LOOKUP",
            "key": key,
            "lower_bounds": lower_bounds,
            "upper_bounds": upper_bounds,
            "N": N,
            "hops": [],  # Initialize hops tracking
        }
        print(f"Node {self.node_id}: Initiating LOOKUP Request: {request}")

        response = self._handle_lookup_request(request)

        # Log the response for debugging
        if response and "hops" in response:
            print(f"Node {self.node_id}: LOOKUP Operation Complete. Hops: {response['hops']}")
        else:
            print(f"Node {self.node_id}: LOOKUP Operation Failed or No Hops Tracked.")

        return response

    def update_key(self, key, updated_data, criteria=None):
        """
        Initiate the UPDATE_KEY operation for a given key with optional criteria and updated data.

        Args:
            key (str): The key (hashed country) to be updated.
            updated_data (dict): Fields to update. Example: {"attributes": {"price": 30.0}, "review": "Updated review"}.
            criteria (dict, optional): Criteria for selecting points to update.
                                    Example: {"review_date": 2019, "rating": 94}.

        Returns:
            dict: Response from the update operation, indicating success or failure.
        """
        request = {
            "operation": "UPDATE_KEY",
            "key": key,
            "data": updated_data,
            "criteria": criteria,  # Optional criteria for filtering
            "hops": [],  # Initialize hops tracking
        }
        print(f"Node {self.node_id}: Initiating UPDATE_KEY Request: {request}")

        # Handle the request
        response = self._handle_update_key_request(request)

        # Optional: Log the final response for debugging
        if response and "hops" in response:
            print(f"Node {self.node_id}: UPDATE_KEY Operation Complete. Hops: {response['hops']}")
        else:
            print(f"Node {self.node_id}: UPDATE_KEY Operation Failed or No Hops Tracked.")

        return response

    def get_keys(self):
        """
        Move keys from nodes in the leaf set if necessary.
        """
        for node_id in self.Lmin + self.Lmax:
            if node_id is not None:
                request = {"operation": "GET_KEYS", "node_id": self.node_id, "hops": []}
                response = self.send_request(self.network.node_ports[node_id], request)

    def _find_next_hop(self, key):
        """
        Find the next hop to forward a request based on the node ID.
        """
        # Check if the key is in the leaf set range
        if self._in_leaf_set(key):
            # If the node_id is in the leaf set
            closest_leaf_id = self._find_closest_leaf_id(key)
            return closest_leaf_id

        # If the key is not in the leaf set, check the routing table
        else:
            i = common_prefix_length(self.node_id, key)
            if i < HASH_HEX_DIGITS:
                next_hop = self.routing_table[i][int(key[i], 16)]

                if next_hop is not None:
                    return next_hop
                # If the routing table entry is empty,
                # scan all the nodes in the network
                else:
                    next_hop = self._find_closest_node_id_all(key)
                    return next_hop
            # If the common prefix length is equal to the length of the node_id,
            # the key is stored at this node
            return self.node_id

    def transmit_state(self):
        """
        Broadcast the arrival of this node to the network, ensuring each node is updated only once.
        """
        request = {
            "operation": "UPDATE_PRESENCE",
            "joining_node_id": self.node_id,
            "hops": [],
        }

        nodes_updated = set()

        def __update_presence(node_id):
            """Helper function to send request and track updates."""
            if node_id and node_id not in nodes_updated and node_id in self.network.node_ports:
                try:
                    self.send_request(self.network.node_ports[node_id], request)
                    nodes_updated.add(node_id)
                except Exception as e:
                    print(f"Error updating presence for {node_id}: {e}")

        # Update the Neighborhood Set (M) nodes
        for node_id in self.neighborhood_set:
            if node_id in self.network.node_ports:  # Ensure node is alive
                __update_presence(node_id)

        # Update the Routing Table (R) nodes
        for row in self.routing_table:
            for node_id in row:
                if node_id in self.network.node_ports:  # Ensure node is alive
                    __update_presence(node_id)

        # Update the Leaf Set (L) nodes
        for node_id in self.Lmin:
            if node_id in self.network.node_ports:  # Ensure node is alive
                __update_presence(node_id)

        for node_id in self.Lmax:
            if node_id in self.network.node_ports:  # Ensure node is alive
                __update_presence(node_id)

    # Data Structure Updates

    def update_routing_table_row(self, request):
        """
        Update the routing table of the current node with the received row.
        """
        row_idx = request["row_idx"]
        received_row = request["received_row"]

        for col_idx in range(len(received_row)):
            entry = received_row[col_idx]
            if entry is None:
                continue
            # Skip if the entry's hex digit at row_idx matches this node's ID at the same index.
            # This avoids conflicts in the routing table.
            if entry[row_idx] == self.node_id[row_idx]:
                continue
            # Update the routing table with the received entry if the current entry is empty
            if self.routing_table[row_idx][col_idx] is None:
                self.routing_table[row_idx][col_idx] = received_row[col_idx]

    def update_routing_table_entry(self, request):
        """
        Update a single entry in the routing table of the current node.
        """
        idx = request["row_idx"]
        node_id = request["node_id"]

        # Update the routing table entry if it is empty
        if self.routing_table[idx][int(node_id[idx], 16)] is None:
            print(f"Node {self.node_id}: Updating Routing Table Entry for new node {node_id}...")
            self.routing_table[idx][int(node_id[idx], 16)] = node_id

    def initialize_neighborhood_set(self, close_node_id, close_node_neighborhood_set):
        """
        Initialize the neighborhood set of the current node using the close_node.
        """

        self.neighborhood_set = close_node_neighborhood_set
        print(
            f"Node {self.node_id}: Copying neighborhood set from the closest node {close_node_id}..."
        )

        # Insert the close node aswell if there is space
        print(
            f"Node {self.node_id}: Adding Close Node {close_node_id} to the neighborhood set aswell..."
        )
        for i in range(len(self.neighborhood_set)):
            if self.neighborhood_set[i] is None:
                self.neighborhood_set[i] = close_node_id
                return

        # If there is no space, replace the farthest node id with the close node
        print(
            f"Node {self.node_id}: No space in the neighborhood set for the close node. Replacing the farthest node..."
        )
        max_dist = -1
        idx = -1
        for i in range(len(self.neighborhood_set)):
            dist_request = {
                "operation": "DISTANCE",
                "node_position": self.position,
                "hops": [],
            }
            response = self.send_request(
                self.network.node_ports[self.neighborhood_set[i]], dist_request
            )
            dist = response["distance"]

            if dist > max_dist:
                max_dist = dist
                idx = i
        self.neighborhood_set[idx] = close_node_id

    def _update_neighborhood_set(self, key):
        """
        Update the neighborhood set of the current node by adding a new key if there's space
        or replacing the farthest node if necessary.
        """
        # Check for an empty slot in the neighborhood set
        for i, neighbor in enumerate(self.neighborhood_set):
            if neighbor is None:
                self.neighborhood_set[i] = key  # Add the key to the empty slot
                return

        # Initialize variables to find the farthest node in the neighborhood set
        max_dist, replace_idx = -1, -1

        # Find the farthest node from the current node in its neighborhood set
        for i, neighbor_id in enumerate(self.neighborhood_set):
            dist_request = {
                "operation": "DISTANCE",
                "node_position": self.position,
                "hops": [],
            }
            response = self.send_request(self.network.node_ports[neighbor_id], dist_request)
            dist = response["distance"]
            if dist > max_dist:
                max_dist, replace_idx = dist, i

        # Check if the new node is closer than the farthest node
        dist_request = {
            "operation": "DISTANCE",
            "node_position": self.position,
            "hops": [],
        }
        response = self.send_request(self.network.node_ports[key], dist_request)
        key_curr_node_dist = response["distance"]
        if key_curr_node_dist < max_dist:
            # Replace the farthest node with the new node
            self.neighborhood_set[replace_idx] = key

    def update_leaf_set(self, request):
        """
        Update the leaf set of the current node based on the provided Lmin, Lmax,
        and key of the node that triggered the update.
        """
        Lmin = request["Lmin"]
        Lmax = request["Lmax"]
        key = request["key"]

        self.Lmin = Lmin.copy()
        self.Lmax = Lmax.copy()

        if hex_compare(key, self.node_id):
            # If key >= this node's ID, update Lmax
            self._update_leaf_list(self.Lmax, key)
        else:
            # Else update Lmin
            self._update_leaf_list(self.Lmin, key)

    def _handle_update_presence_request(self, request):
        """
        Update the presence of a node in all the data structures of this node.
        """
        key = request["joining_node_id"]

        # Update Neighborhood Set (M)
        if key not in self.neighborhood_set:
            self._update_neighborhood_set(key)

        # Update Routing Table (R)
        idx = common_prefix_length(key, self.node_id)

        # If the entry in the routing table is empty, update it with the key
        print(
            f"Node {self.node_id}: Updating Routing Table Entry {idx, int(key[idx], 16)} for new node {key}..."
        )
        if self.routing_table[idx][int(key[idx], 16)] is None:
            self.routing_table[idx][int(key[idx], 16)] = key

        # Update the new node's routing table with the current node's ID
        request = {
            "operation": "UPDATE_ROUTING_TABLE_ENTRY",
            "row_idx": idx,
            "node_id": self.node_id,
            "hops": [],
        }
        self.send_request(self.network.node_ports[key], request)

        # Update Leaf Set (Lmin, Lmax)
        print(f"Node {self.node_id}: Updating Leaf Set for new node {key}...")

        if key >= self.node_id:
            self._update_leaf_list(self.Lmax, key)
        else:
            self._update_leaf_list(self.Lmin, key)

    # Helper Methods

    def _in_leaf_set(self, key):
        """
        Check if a key is in the range of the leaf set.
        """
        # Get the biggest node in Lmax
        lmax_max = self.Lmax[0]
        if lmax_max is not None:
            for node_id in self.Lmax:
                if node_id is not None:
                    if hex_compare(node_id, lmax_max):
                        lmax_max = node_id
        else:
            # If lmax_max is None we need to check Lmin for the biggest node
            lmax_max = self.Lmin[0]
            for node_id in self.Lmin:
                if node_id is not None:
                    if hex_compare(node_id, lmax_max):
                        lmax_max = node_id

        # Get the smallest node in Lmin
        lmin_min = self.Lmin[0]
        if lmin_min is not None:
            for node_id in self.Lmin:
                if node_id is not None:
                    if hex_compare(lmin_min, node_id):
                        lmin_min = node_id
        else:
            # If lmin_min is None we need to check Lmax for the smallest node
            if lmin_min is None:
                lmin_min = self.Lmax[0]
                for node_id in self.Lmax:
                    if node_id is not None:
                        if hex_compare(lmin_min, node_id):
                            lmin_min = node_id

        # Check if the key is between lmin_min and lmax_max
        if lmin_min is not None and lmax_max is not None:
            return hex_compare(key, lmin_min) and hex_compare(lmax_max, key)

    def _find_closest_leaf_id(self, key):
        closest_diff_dig_idx, closest_dist = hex_distance(self.node_id, key)

        closest_leaf_id = self.node_id

        # Check Lmin for closer nodes
        for leaf in self.Lmin:
            if leaf is not None:
                key_leaf_diff_dig_idx, key_leaf_dist = hex_distance(leaf, key)

                # Update if the different digit index is grater
                # or if its the same but this node is numerically closer
                if (key_leaf_diff_dig_idx > closest_diff_dig_idx) or (
                    key_leaf_diff_dig_idx == closest_diff_dig_idx and key_leaf_dist < closest_dist
                ):
                    closest_leaf_id = leaf
                    closest_diff_dig_idx = key_leaf_diff_dig_idx
                    closest_dist = key_leaf_dist

        # Check Lmax for closer nodes
        for leaf in self.Lmax:
            if leaf is not None:
                key_leaf_diff_dig_idx, key_leaf_dist = hex_distance(leaf, key)

                # Apply the same update logic
                if (key_leaf_diff_dig_idx > closest_diff_dig_idx) or (
                    key_leaf_diff_dig_idx == closest_diff_dig_idx and key_leaf_dist < closest_dist
                ):
                    closest_leaf_id = leaf
                    closest_diff_dig_idx = key_leaf_diff_dig_idx
                    closest_dist = key_leaf_dist

        return closest_leaf_id

    def _find_closest_node_id_all(self, key):
        """
        Scan all the nodes in the network to find the closest node to the given node ID.
        """
        l = common_prefix_length(self.node_id, key)

        # Check Lmin
        for idx in range(len(self.Lmin)):
            if self.Lmin[idx] is not None:
                if self._is_closer_node(self.Lmin[idx], key, l, self.node_id):
                    return self.Lmin[idx]

        # Check Lmax
        for idx in range(len(self.Lmax)):
            if self.Lmax[idx] is not None:
                if self._is_closer_node(self.Lmax[idx], key, l, self.node_id):
                    return self.Lmax[idx]

        # Check neighborhood set (M)
        for idx in range(len(self.neighborhood_set)):
            if self.neighborhood_set[idx] is not None:
                if self._is_closer_node(self.neighborhood_set[idx], key, l, self.node_id):
                    return self.neighborhood_set[idx]

        # Check routing table (R)
        for row in range(len(self.routing_table)):
            for col in range(len(self.routing_table[0])):
                if self.routing_table[row][col] is not None:
                    if self._is_closer_node(self.routing_table[row][col], key, l, self.node_id):
                        return self.routing_table[row][col]

        # If no node is found, return the current node ID
        return self.node_id

    def _is_closer_node(self, target_node_id, key, l, curr_node_id):
        """
        Custom condition to compare the target and current nodes based on topological and numerical closeness to the key.
        """
        # Calculate the common prefix length between the target node and the key
        i = common_prefix_length(target_node_id, key)

        # Calculate the first different digit index between the target node id and the key
        # and the numerical distance between the target node and the key
        target_key_diff_dig_idx, target_key_num_dist = hex_distance(target_node_id, key)

        # Do the same for the current node and the key
        curr_node_key_diff_dig_idx, curr_node_key_num_dist = hex_distance(curr_node_id, key)

        # Determine if the target node is a better candidate than the current node
        if (i >= l) and (
            (target_key_diff_dig_idx > curr_node_key_diff_dig_idx)
            or (
                target_key_diff_dig_idx == curr_node_key_diff_dig_idx
                and target_key_num_dist < curr_node_key_num_dist
            )
        ):
            return True
        else:
            return False

    def _update_leaf_list(self, leaf_list, key):
        """
        Update the specified leaf list (Lmin or Lmax) with the given key.
        Ensures it remains sorted and does not contain duplicates.
        """
        if key in self.Lmin or key in self.Lmax:
            return  # Key is already in the leaf set

        # Find an empty slot
        for i in range(len(leaf_list)):
            if leaf_list[i] is None:
                leaf_list[i] = key
                return

        # If no empty slot, find the farthest node and replace it if the key is closer
        far_diff_dig_idx = HASH_HEX_DIGITS
        max_num_dist = -1
        replace_index = -1

        for i in range(len(leaf_list)):
            diff_dig_idx, num_dist = hex_distance(leaf_list[i], self.node_id)

            # Replace the farthest node (numerical distance or digit index)
            if (diff_dig_idx < far_diff_dig_idx) or (
                diff_dig_idx == far_diff_dig_idx and num_dist > max_num_dist
            ):
                far_diff_dig_idx = diff_dig_idx
                max_num_dist = num_dist
                replace_index = i

        # Calculate the numerical distance for the new key
        diff_dig_idx, num_dist = hex_distance(key, self.node_id)

        # Replace if the key is closer than the farthest node
        if (diff_dig_idx > far_diff_dig_idx) or (
            diff_dig_idx == far_diff_dig_idx and num_dist < max_num_dist
        ):
            leaf_list[replace_index] = key
